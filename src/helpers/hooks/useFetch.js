import { useEffect, useState } from "react";

export function useFetch(fetchFunction, params) {
    const [data, setData] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);

    const stringParams = params ? new URLSearchParams(params).toString() : '';

    useEffect(() => {
        // Это явный пример IIFE (Immediately invoked function expression) или "немедленно вызываемое функциональное выражение".
        // Это означает, что функция выполняется сразу же после того, как она была определена.
        // Оно состоит из 2-ух частей:
        // 1. Анонимная функция, заключённая в (). Благодаря этому переменные IIFE замыкаются 
        //    в его пределах, и глобальная область видимости иои не засоряется.
        // 2. Вторая часть создаёт мгновенно выполняющееся функциональное выражение "()",
        //    благодаря которому JavaScript-движок выполняет функцию напрямую.

        // Его можно записать ввиде обычной так и стрелочной функции, как сдесь и видно.
        (async () => {
            try {
                setIsLoading(true);
                const result = await fetchFunction(params);
                setData(result);
            } catch (error) {
                setError(error);
            } finally {
                setIsLoading(false);
            }
        })();
        // useEffeсt может зависеть от функции, так как когда компонент рендериться заново, то
        // функция создаётся снова (функция должна быть внутри компонента) и изменяется её ссылка,
        // которую и отслеживает useEffect, даже если сама логика функции не изменилась.

        // Стоит отслеживать функцию в useEffect, когда внутри него используется эта функция
        // (например, для подписки на события или для каких-то сложных вычислений), и ты 
        // хочешь быть уверенным, что у тебя всегда будет актуальная версия функции.

        // В данном примере это не работает, так как функия, которая нам передаётся через параметр
        // объявлена в обычном файле js, который не является компонентом и не создаётся заново, при 
        // повторном рендере, так как он вообщее не рендериться и следовательно ссылка на функцию не меняется
        // и useEffect не срабатывает. Он срабатывает только на параметры, которые мы передаём, так как они являются 
        // состоянием. Но для примера это функция в зависимости останеться.
    }, [ fetchFunction, stringParams ]);

    return { data, isLoading, error };
}
